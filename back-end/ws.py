from flask import Flask, jsonify, request
from flask_caching import Cache
from flask_cors import CORS
from flask_websockets import WebSockets, ws
from matplotlib import pyplot as plt
import codecs
import io
import json
import scanpy as sc
import uuid

sc.settings.verbosity = 0
plt.switch_backend('agg')

THREE_DAYS = 3 * 24 * 60 * 60

app = Flask(__name__)

file_cache_config = {
    "CACHE_TYPE": "FileSystemCache",
    "CACHE_DEFAULT_TIMEOUT": THREE_DAYS,
    "CACHE_IGNORE_ERRORS": False,  # Default
    "CACHE_DIR": 'back-end-cache',
    "CACHE_THRESHOLD": 500,        # Default
}
user_cache_config = file_cache_config
accepting_user_requests = Cache(config=user_cache_config)
accepting_user_requests.init_app(app)

CORS(app)
sockets = WebSockets(app)

pbmc3k = None


@app.route('/api/getuserid')
def get_user_id():
    user_id = request.args.get('user_id')
    if user_id is None:
        raise ValueError
    else:
        if user_id == '':
            user_id = str(uuid.uuid4())
        message = {
            'user_id': user_id
        }
        return jsonify(message)


class UserIDException(Exception):
    pass


class NotAcceptingRequestException(Exception):
    pass


@sockets.on_message
def execute_blocks(message_json):
    try:
        message = json.loads(message_json)
        user_id = message['user_id']
        if user_id is None or user_id == '':
            raise UserIDException
        elif accepting_user_requests.get(user_id) is False:
            raise NotAcceptingRequestException
        user_data = None
        accepting_user_requests.set(user_id, False)
        blocks = message['blocks']
        for block in blocks:
            if block['block_id'] == 'loaddata':
                user_data, output_message = load_data(user_data)
            elif block['block_id'] == 'basicfiltering':
                min_genes = block['min_genes']
                min_cells = block['min_cells']
                user_data, output_message = basic_filtering(user_data, min_genes, min_cells)
            elif block['block_id'] == 'qcplots':
                user_data, output_message = qc_plots(user_data)
            else:
                raise ValueError
            ws.send(json.dumps(output_message))
        end_connection = json.dumps({'end_connection': 'end_connection'})
    except UserIDException:
        end_connection = json.dumps({'error': 'Your UserID is invalid, please refresh the page and try again'})
    except NotAcceptingRequestException:
        end_connection = json.dumps({'error': 'You have another request in progress, please wait and try again'})
    except KeyError:
        end_connection = json.dumps({'error': 'Received an incomplete request, please refresh the page and try again'})
    except ValueError:
        end_connection = json.dumps({'error': 'Received a bad request, please refresh the page and try again'})
    except Exception:
        end_connection = json.dumps({'error': 'Unknown error, please refresh the page and try again'})
    finally:
        ws.send(end_connection)
        accepting_user_requests.set(user_id, True)


def load_data(user_data):
    new_adata = sc.datasets.pbmc3k()
    message = {
        'text': str(new_adata)
    }
    return new_adata, message


def basic_filtering(user_data, min_genes, min_cells):
    min_genes = float(min_genes)
    min_cells = float(min_cells)
    new_adata = user_data.copy()
    sc.pp.filter_cells(new_adata, min_genes=min_genes)
    sc.pp.filter_genes(new_adata, min_cells=min_cells)
    message = {
        'text': str(new_adata)
    }
    return new_adata, message


def qc_plots(user_data):
    new_adata = user_data.copy()
    new_adata.var['mt'] = new_adata.var_names.str.startswith('MT-')
    sc.pp.calculate_qc_metrics(new_adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)
    new_adata.obs['total_UMIs'] = new_adata.obs['total_counts']
    new_adata.obs = new_adata.obs.drop('total_counts', axis=1)
    plt.rcParams['font.size'] = 18
    sc.pl.violin(new_adata, ['n_genes_by_counts', 'total_UMIs', 'pct_counts_mt'], jitter=0.4, multi_panel=True, show=False)
    image_stream = io.BytesIO()
    plt.savefig(image_stream, format='png')
    image_stream.seek(0)
    message = {
        'img': str(codecs.encode(image_stream.read(), 'base64')),
        'alttext': 'A violin plot displaying quality control metrics generated by a QC Plots block',
    }
    return new_adata, message


if __name__ == '__main__':
    from gevent import pywsgi
    from geventwebsocket.handler import WebSocketHandler
    server = pywsgi.WSGIServer(('127.0.0.1', 5000), app, handler_class=WebSocketHandler)
    server.serve_forever()
